"""
Enhanced main.py example showing integration of all improvements.
This demonstrates how to integrate the new modules for better performance,
error handling, memory management, and code organization.

NOTE: This is an example file showing integration patterns.
Use these patterns to enhance your existing main.py file.
"""

import asyncio
import signal
import time
from datetime import datetime
from typing import Dict, List, Optional

# Import enhanced modules
from modules.logger import (
    structured_logger, error_aggregator, perf_logger, 
    performance_monitor, async_performance_monitor
)
from modules.memory_manager import memory_manager, cached, resource_tracker
from modules.performance import (
    batch_processor, connection_pool, performance_monitor as perf_mon,
    optimized_send_message, cleanup_performance_components
)
from modules.shutdown_handler import (
    shutdown_handler, register_shutdown_callback, register_async_shutdown_callback,
    register_resource_cleanup, graceful_shutdown
)
from modules.utilities import (
    convert_discord_message, retry_with_backoff, get_memory_usage,
    format_uptime, is_spam_content
)
from modules.types import MessageData, TokenConfig, ServerInfo, BotStatus

# Original imports (keep your existing imports)
import discord
import json
import os
import aiohttp
import redis
from dotenv import load_dotenv

class EnhancedMirrorSelfBot(discord.Client):
    """Enhanced self-bot with improved error handling, performance, and monitoring."""
    
    def __init__(self, token: str, monitored_servers: set, **kwargs):
        super().__init__(**kwargs)
        self.token = token
        self.monitored_servers = monitored_servers
        self.start_time = time.time()
        self.status = BotStatus.STARTING
        self.message_count = 0
        
        # Register for cleanup
        register_resource_cleanup(self, self.cleanup)
    
    async def setup_hook(self):
        """Enhanced setup with proper resource management."""\n        structured_logger.info(\n            \"Bot setup initiated\",\n            bot_id=str(self.user.id) if self.user else \"unknown\",\n            monitored_servers=len(self.monitored_servers)\n        )\n        \n        # Start performance components\n        await batch_processor.start()\n        \n        # Register shutdown callbacks\n        register_async_shutdown_callback(self.graceful_stop)\n        \n        self.status = BotStatus.RUNNING\n    \n    @async_performance_monitor\n    async def on_message(self, message: discord.Message):\n        \"\"\"Enhanced message handler with performance monitoring and error handling.\"\"\"\n        correlation_id = None\n        \n        try:\n            # Use correlation context for request tracking\n            with structured_logger.correlation_context() as corr_id:\n                correlation_id = corr_id\n                await self._process_message_enhanced(message)\n        \n        except Exception as e:\n            # Enhanced error handling\n            error_aggregator.record_error(\n                type(e).__name__,\n                str(e),\n                {\n                    \"message_id\": message.id,\n                    \"server_id\": message.guild.id if message.guild else None,\n                    \"channel_id\": message.channel.id,\n                    \"correlation_id\": correlation_id\n                }\n            )\n            \n            structured_logger.error(\n                \"Message processing failed\",\n                error_type=type(e).__name__,\n                error_message=str(e),\n                message_id=message.id,\n                correlation_id=correlation_id\n            )\n    \n    async def _process_message_enhanced(self, message: discord.Message):\n        \"\"\"Process message with enhanced features.\"\"\"\n        start_time = time.time()\n        \n        # Skip self-messages and bots\n        if message.author == self.user:\n            return\n        \n        # Server validation with caching\n        server_id = str(message.guild.id) if message.guild else \"dm\"\n        if server_id not in self.monitored_servers:\n            return\n        \n        # Spam detection\n        if message.content and is_spam_content(message.content):\n            structured_logger.warning(\n                \"Spam content detected - skipping\",\n                message_id=message.id,\n                server_id=server_id\n            )\n            return\n        \n        # Convert to standardized format\n        message_data = convert_discord_message(message)\n        \n        # Enhanced sending with batch processing and connection pooling\n        destination_url = \"http://127.0.0.1:5000/process_message\"\n        await optimized_send_message(message_data.to_dict(), destination_url)\n        \n        # Update metrics\n        processing_time = time.time() - start_time\n        self.message_count += 1\n        \n        perf_logger.log_message_processing(\n            server_id, \n            1, \n            processing_time\n        )\n        \n        structured_logger.info(\n            \"Message processed successfully\",\n            message_id=message.id,\n            server_id=server_id,\n            processing_time_ms=round(processing_time * 1000, 2),\n            total_processed=self.message_count\n        )\n    \n    async def graceful_stop(self):\n        \"\"\"Gracefully stop the bot.\"\"\"\n        structured_logger.info(\"Initiating bot graceful shutdown\")\n        self.status = BotStatus.STOPPING\n        \n        try:\n            await self.close()\n            self.status = BotStatus.STOPPED\n            structured_logger.info(\"Bot stopped successfully\")\n        except Exception as e:\n            structured_logger.error(\n                \"Error during bot shutdown\",\n                error_type=type(e).__name__,\n                error_message=str(e)\n            )\n    \n    def cleanup(self):\n        \"\"\"Cleanup bot resources.\"\"\"\n        structured_logger.info(f\"Cleaning up bot resources for token {self.token[:10]}***\")\n    \n    def get_stats(self) -> Dict[str, any]:\n        \"\"\"Get bot performance statistics.\"\"\"\n        uptime = time.time() - self.start_time\n        \n        return {\n            \"status\": self.status.value,\n            \"uptime\": format_uptime(self.start_time),\n            \"uptime_seconds\": uptime,\n            \"messages_processed\": self.message_count,\n            \"messages_per_second\": self.message_count / uptime if uptime > 0 else 0,\n            \"monitored_servers\": len(self.monitored_servers)\n        }\n\nclass EnhancedConfigManager:\n    \"\"\"Enhanced configuration management with validation and caching.\"\"\"\n    \n    def __init__(self, config_file: str = \"config.json\"):\n        self.config_file = config_file\n        self._config_cache = memory_manager.get_cache(\"config\", ttl_seconds=60)\n        \n    @cached(\"config_load\", ttl_seconds=60)\n    def load_config(self) -> Dict:\n        \"\"\"Load configuration with caching.\"\"\"\n        try:\n            with open(self.config_file, \"r\", encoding=\"utf-8\") as f:\n                config = json.load(f)\n            \n            structured_logger.info(\n                \"Configuration loaded successfully\",\n                config_file=self.config_file,\n                tokens_count=len(config.get(\"tokens\", {}))\n            )\n            \n            return config\n            \n        except Exception as e:\n            error_aggregator.record_error(\n                \"ConfigLoadError\",\n                f\"Failed to load {self.config_file}: {e}\"\n            )\n            raise\n    \n    def validate_config(self, config: Dict) -> List[str]:\n        \"\"\"Validate configuration and return list of errors.\"\"\"\n        errors = []\n        \n        # Validate required sections\n        required_sections = [\"tokens\", \"settings\"]\n        for section in required_sections:\n            if section not in config:\n                errors.append(f\"Missing required section: {section}\")\n        \n        # Validate tokens\n        if \"tokens\" in config:\n            for token, token_config in config[\"tokens\"].items():\n                if not isinstance(token, str) or len(token) < 20:\n                    errors.append(f\"Invalid token format: {token[:10]}***\")\n        \n        return errors\n\nasync def enhanced_main():\n    \"\"\"Enhanced main function with all improvements integrated.\"\"\"\n    structured_logger.info(\"Starting Enhanced 1Tap Notify System\")\n    \n    try:\n        # Initialize components\n        config_manager = EnhancedConfigManager()\n        config = config_manager.load_config()\n        \n        # Validate configuration\n        config_errors = config_manager.validate_config(config)\n        if config_errors:\n            for error in config_errors:\n                structured_logger.error(\"Configuration error\", error=error)\n            raise ValueError(f\"Configuration validation failed: {config_errors}\")\n        \n        # Start memory manager\n        memory_manager.start_cleanup_thread()\n        \n        # Initialize bots with enhanced error handling\n        bots = []\n        enabled_tokens = [(t, d) for t, d in config[\"tokens\"].items() \n                         if not d.get(\"disabled\", False)]\n        \n        for token, token_data in enabled_tokens:\n            server_ids = set(token_data[\"servers\"].keys())\n            \n            try:\n                bot = EnhancedMirrorSelfBot(\n                    token=token,\n                    monitored_servers=server_ids,\n                    intents=discord.Intents.default()\n                )\n                bots.append(bot)\n                \n                structured_logger.info(\n                    \"Bot initialized\",\n                    token_preview=token[:10] + \"***\",\n                    server_count=len(server_ids)\n                )\n                \n            except Exception as e:\n                error_aggregator.record_error(\n                    \"BotInitializationError\",\n                    f\"Failed to initialize bot: {e}\",\n                    {\"token\": token[:10] + \"***\"}\n                )\n        \n        # Start bots with staggered launch\n        bot_tasks = []\n        for i, bot in enumerate(bots):\n            await asyncio.sleep(i * 2)  # 2-second stagger\n            task = asyncio.create_task(bot.start(bot.token))\n            bot_tasks.append(task)\n        \n        structured_logger.info(\n            \"All bots started\",\n            bot_count=len(bots),\n            memory_usage=get_memory_usage()\n        )\n        \n        # Monitor system health\n        await monitor_system_health(bots)\n        \n    except KeyboardInterrupt:\n        structured_logger.info(\"Shutdown signal received\")\n    except Exception as e:\n        structured_logger.error(\n            \"Critical error in main loop\",\n            error_type=type(e).__name__,\n            error_message=str(e)\n        )\n        raise\n    finally:\n        # Graceful shutdown\n        await graceful_shutdown()\n\nasync def monitor_system_health(bots: List[EnhancedMirrorSelfBot]):\n    \"\"\"Monitor system health and performance.\"\"\"\n    while not shutdown_handler.is_shutting_down:\n        try:\n            # Collect metrics\n            memory_stats = memory_manager.get_memory_stats()\n            error_summary = error_aggregator.get_error_summary()\n            performance_stats = perf_mon.get_summary()\n            \n            # Log health metrics\n            structured_logger.info(\n                \"System health check\",\n                memory_caches=memory_stats[\"total_caches\"],\n                total_errors=error_summary[\"total_error_count\"],\n                active_bots=len([b for b in bots if b.status == BotStatus.RUNNING]),\n                uptime=performance_stats.get(\"uptime_seconds\", 0)\n            )\n            \n            # Check for issues\n            if error_summary[\"total_error_count\"] > 100:\n                structured_logger.warning(\n                    \"High error count detected\",\n                    error_count=error_summary[\"total_error_count\"]\n                )\n            \n            # Memory optimization\n            if memory_stats[\"summary\"][\"total_entries\"] > 50000:\n                optimization_results = memory_manager.optimize_memory()\n                structured_logger.info(\n                    \"Memory optimization performed\",\n                    **optimization_results\n                )\n            \n        except Exception as e:\n            structured_logger.error(\n                \"Health monitoring error\",\n                error_type=type(e).__name__,\n                error_message=str(e)\n            )\n        \n        await asyncio.sleep(60)  # Check every minute\n\nif __name__ == \"__main__\":\n    # Set up signal handlers for graceful shutdown\n    def signal_handler(sig, frame):\n        print(\"\\nShutdown signal received\")\n        shutdown_handler.is_shutting_down = True\n    \n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n    \n    # Run enhanced main\n    try:\n        asyncio.run(enhanced_main())\n    except KeyboardInterrupt:\n        print(\"Application terminated by user\")\n    except Exception as e:\n        print(f\"Application terminated with error: {e}\")\n        import traceback\n        traceback.print_exc()\n    finally:\n        print(\"Cleanup completed\")